#include "../include/code_emitter.h"
#include <iomanip>
#include <sstream>
#include <cstring>

// ===--------------------------------------------------------------------=== //
// RISC-V 代码发射器实现
// ===--------------------------------------------------------------------=== //

void RISCVCodeEmitter::emitModule(const MachineModule& module) {
  emitHeader();
  
  // 输出全局变量定义
  if (!module.global_variables.empty()) {
    emitDataSection();
    for (const auto& global_var : module.global_variables) {
      emitGlobalVariable(global_var);
    }
    *output_stream << "\n";
  }
  
  emitTextSection();
  
  for (const auto& func : module.functions) {
    emitFunction(*func);
    *output_stream << "\n";
  }
}

void RISCVCodeEmitter::emitFunction(const MachineFunction& func) {
  emitComment("Function: " + func.name);
  emitGlobalDirective(func.name);
  emitFunctionLabel(func.name);
  
  // 生成函数序言
  emitFunctionPrologue(func);
  
  // 遍历所有基本块，但需要特殊处理最后的返回指令
  for (const auto& block : func.basic_blocks) {
    emitBasicBlockWithEpilogueHandling(*block, func);
  }
}

void RISCVCodeEmitter::emitBasicBlockWithEpilogueHandling(const MachineBasicBlock& block, const MachineFunction& func) {
  // 只为非首个基本块输出标签
  if (block.block_id != 0) {
    emitBlockLabel(block.block_id);
  }
  
  for (size_t i = 0; i < block.instructions.size(); ++i) {
    const auto& inst = block.instructions[i];
    
    // 检查是否是返回指令
    bool is_return_instruction = false;
    if (inst->opcode == RISCVOpcode::JALR) {
      if (inst->operands.size() == 3 && 
          inst->operands[0].isReg() && inst->operands[0].reg->reg_num == 0 &&
          inst->operands[1].isReg() && inst->operands[1].reg->reg_num == 1 &&
          inst->operands[2].isImm() && inst->operands[2].imm == 0) {
        is_return_instruction = true;
      }
    }
    
    if (is_return_instruction) {
      // 如果是返回指令，生成函数尾声而不是简单的ret
      emitFunctionEpilogue(func);
    } else {
      // 普通指令正常输出
      emitInstruction(*inst);
    }
  }
}

void RISCVCodeEmitter::emitFunctionPrologue(const MachineFunction& func) {
  // 计算栈帧大小，需要对齐到16字节边界（RISC-V ABI要求）
  int frame_size = func.stack_size;
  if (frame_size > 0) {
    // 向上对齐到16字节边界
    frame_size = (frame_size + 15) & ~15;
    
    emitComment("Function prologue");
    // 保存返回地址和设置帧指针
    *output_stream << "    addi sp, sp, -" << frame_size << "\n";
    
    // 保存返回地址 (ra) 
    if (frame_size >= 8) {
      *output_stream << "    sw ra, " << (frame_size - 4) << "(sp)\n";
    }
    
    // 保存帧指针 (s0/fp) 并设置新的帧指针
    if (frame_size >= 12) {
      *output_stream << "    sw s0, " << (frame_size - 8) << "(sp)\n";
      *output_stream << "    addi s0, sp, " << frame_size << "\n";
    }
  }
}

void RISCVCodeEmitter::emitFunctionEpilogue(const MachineFunction& func) {
  // 计算栈帧大小，需要对齐到16字节边界
  int frame_size = func.stack_size;
  if (frame_size > 0) {
    // 向上对齐到16字节边界
    frame_size = (frame_size + 15) & ~15;
    
    emitComment("Function epilogue");
    
    // 恢复帧指针 (s0/fp)
    if (frame_size >= 12) {
      *output_stream << "    lw s0, " << (frame_size - 8) << "(sp)\n";
    }
    
    // 恢复返回地址 (ra)
    if (frame_size >= 8) {
      *output_stream << "    lw ra, " << (frame_size - 4) << "(sp)\n";
    }
    
    // 恢复栈指针
    *output_stream << "    addi sp, sp, " << frame_size << "\n";
    *output_stream << "    ret\n";
  } else {
    // 如果没有栈帧，直接返回
    *output_stream << "    ret\n";
  }
}

void RISCVCodeEmitter::emitBasicBlock(const MachineBasicBlock& block) {
  // 只为非首个基本块输出标签
  if (block.block_id != 0) {
    emitBlockLabel(block.block_id);
  }
  
  for (const auto& inst : block.instructions) {
    emitInstruction(*inst);
  }
}

void RISCVCodeEmitter::emitInstruction(const MachineInstruction& inst) {
  if (needsSpecialHandling(inst)) {
    handleSpecialInstruction(inst);
    return;
  }
  
  std::string formatted = formatInstruction(inst);
  *output_stream << "    " << formatted << "\n";
}

void RISCVCodeEmitter::emitHeader() {
  *output_stream << "# RISC-V Assembly Code\n";
  *output_stream << "# Generated by SYS Compiler with GlobalISel\n";
  *output_stream << "\n";
}

void RISCVCodeEmitter::emitFunctionLabel(const std::string& name) {
  *output_stream << name << ":\n";
}

void RISCVCodeEmitter::emitBlockLabel(int block_id) {
  *output_stream << ".L" << block_id << ":\n";
}

std::string RISCVCodeEmitter::formatInstruction(const MachineInstruction& inst) {
  std::string opcode_str;
  
  // 将操作码转换为汇编指令名
  switch (inst.opcode) {
    case RISCVOpcode::ADD: opcode_str = "add"; break;
    case RISCVOpcode::ADDI: opcode_str = "addi"; break;
    case RISCVOpcode::SUB: opcode_str = "sub"; break;
    case RISCVOpcode::MUL: opcode_str = "mul"; break;
    case RISCVOpcode::DIV: opcode_str = "div"; break;
    case RISCVOpcode::LW: opcode_str = "lw"; break;
    case RISCVOpcode::SW: opcode_str = "sw"; break;
    case RISCVOpcode::JAL: opcode_str = "jal"; break;
    case RISCVOpcode::JALR: 
      // 检查是否是ret伪指令 (jalr x0, ra, 0)
      if (inst.operands.size() == 3 && 
          inst.operands[0].isReg() && inst.operands[0].reg->reg_num == 0 &&
          inst.operands[1].isReg() && inst.operands[1].reg->reg_num == 1 &&
          inst.operands[2].isImm() && inst.operands[2].imm == 0) {
        opcode_str = "ret";
      } else {
        opcode_str = "jalr";
      }
      break;
    case RISCVOpcode::LI: opcode_str = "li"; break;
    case RISCVOpcode::LA: opcode_str = "la"; break;
    case RISCVOpcode::MV: opcode_str = "mv"; break;
    case RISCVOpcode::NOP: opcode_str = "nop"; break;
    case RISCVOpcode::SLT: opcode_str = "slt"; break;
    case RISCVOpcode::SLTI: opcode_str = "slti"; break;
    case RISCVOpcode::SLTU: opcode_str = "sltu"; break;
    case RISCVOpcode::SLTIU: opcode_str = "sltiu"; break;
    case RISCVOpcode::BEQ: opcode_str = "beq"; break;
    case RISCVOpcode::BNE: opcode_str = "bne"; break;
    case RISCVOpcode::BLT: opcode_str = "blt"; break;
    case RISCVOpcode::BGE: opcode_str = "bge"; break;
    case RISCVOpcode::BLTU: opcode_str = "bltu"; break;
    case RISCVOpcode::BGEU: opcode_str = "bgeu"; break;
    case RISCVOpcode::FADD_S: opcode_str = "fadd.s"; break;
    case RISCVOpcode::FSUB_S: opcode_str = "fsub.s"; break;
    case RISCVOpcode::FMUL_S: opcode_str = "fmul.s"; break;
    case RISCVOpcode::FDIV_S: opcode_str = "fdiv.s"; break;
    case RISCVOpcode::FEQ_S: opcode_str = "feq.s"; break;
    case RISCVOpcode::FLT_S: opcode_str = "flt.s"; break;
    case RISCVOpcode::FLE_S: opcode_str = "fle.s"; break;
    default: 
      opcode_str = "unknown";
      break;
  }
  
  std::stringstream ss;
  ss << std::left << std::setw(8) << opcode_str;
  
  // 特殊处理ret和nop指令，不显示操作数
  if (opcode_str == "ret" || opcode_str == "nop") {
    return ss.str();
  }
  
  // 特殊处理MV指令的立即数情况
  if (inst.opcode == RISCVOpcode::MV && inst.operands.size() >= 2) {
    // 检查第二个操作数是否是立即数
    if (inst.operands[1].isImm()) {
      // 将MV指令转换为LI指令
      ss.str("");  // 清空当前内容
      ss << std::left << std::setw(8) << "li";
      ss << formatOperand(inst.operands[0]) << ", ";  // 目标寄存器
      ss << formatOperand(inst.operands[1]);          // 立即数
      return ss.str();
    }
  }
  
  // 特殊处理SW和LW指令的地址格式
  if (inst.opcode == RISCVOpcode::SW || inst.opcode == RISCVOpcode::LW) {
    // 检查是否有全局变量操作数
    if (inst.operands.size() >= 2 && inst.operands[1].type == MachineOperand::GLOBAL) {
      // 对于全局变量，使用临时寄存器处理
      std::stringstream la_ss;
      la_ss << std::left << std::setw(8) << "la";
      la_ss << "t6, " << formatOperand(inst.operands[1]);  // 使用t6作为临时寄存器
      
      // 输出LA指令
      *output_stream << "    " << la_ss.str() << "\n";
      
      // 现在生成LW/SW指令，使用t6寄存器
      ss << formatOperand(inst.operands[0]) << ", ";  // 目标/源寄存器
      ss << "0(t6)";                                  // 0(t6) - 从全局变量地址加载
      return ss.str();
    }
    
    if (inst.operands.size() >= 3) {
      // 三操作数格式: [src/dst_reg, offset, base_reg]
      // 对于SW指令，检查第一个操作数是否是立即数
      if (inst.opcode == RISCVOpcode::SW && inst.operands[0].isImm()) {
        // 需要先生成LI指令将立即数加载到临时寄存器
        std::stringstream li_ss;
        li_ss << std::left << std::setw(8) << "li";
        li_ss << "t6, " << formatOperand(inst.operands[0]);  // 使用t6作为临时寄存器
        
        // 输出LI指令
        *output_stream << "    " << li_ss.str() << "\n";
        
        // 现在生成SW指令，使用t6寄存器
        ss << "t6, ";                                        // 使用t6寄存器
        ss << formatOperand(inst.operands[1]);               // 偏移量
        ss << "(" << formatOperand(inst.operands[2]) << ")"; // (基址寄存器)
        return ss.str();
      } else {
        // 正常的寄存器操作
        // 格式: sw/lw reg, offset(base) 
        // 操作数顺序: [src/dst_reg, offset, base_reg]
        ss << formatOperand(inst.operands[0]) << ", ";           // 源/目标寄存器
        ss << formatOperand(inst.operands[1]);                   // 偏移量
        ss << "(" << formatOperand(inst.operands[2]) << ")";     // (基址寄存器)
        return ss.str();
      }
    } else if (inst.operands.size() == 2) {
      // 两操作数格式: [src/dst_reg, address_reg]，需要转换为 reg, 0(address_reg)
      // 对于SW指令，检查第一个操作数是否是立即数
      if (inst.opcode == RISCVOpcode::SW && inst.operands[0].isImm()) {
        // 需要先生成LI指令将立即数加载到临时寄存器
        std::stringstream li_ss;
        li_ss << std::left << std::setw(8) << "li";
        li_ss << "t6, " << formatOperand(inst.operands[0]);  // 使用t6作为临时寄存器
        
        // 输出LI指令
        *output_stream << "    " << li_ss.str() << "\n";
        
        // 现在生成SW指令，使用t6寄存器
        ss << "t6, 0(" << formatOperand(inst.operands[1]) << ")"; // 使用t6寄存器，偏移为0
        return ss.str();
      } else {
        // 正常的寄存器操作
        ss << formatOperand(inst.operands[0]) << ", ";           // 源/目标寄存器
        ss << "0(" << formatOperand(inst.operands[1]) << ")";    // 0(基址寄存器)
        return ss.str();
      }
    }
  }
  
  // 通用操作数格式化
  for (size_t i = 0; i < inst.operands.size(); ++i) {
    if (i > 0) ss << ", ";
    ss << formatOperand(inst.operands[i]);
  }
  
  return ss.str();
}

std::string RISCVCodeEmitter::formatOperand(const MachineOperand& operand) {
  switch (operand.type) {
    case MachineOperand::REG:
      return formatRegister(*operand.reg);
    case MachineOperand::IMM:
      return formatImmediate(operand.imm);
    case MachineOperand::FIMM:
      return formatFloatImmediate(operand.fimm);
    case MachineOperand::LABEL:
      return ".L" + std::to_string(operand.label_id);
    case MachineOperand::GLOBAL:
      return *operand.global_name;
    case MachineOperand::STACK_SLOT:
      return std::to_string(operand.stack_slot) + "(sp)";
    default:
      return "unknown";
  }
}

std::string RISCVCodeEmitter::formatRegister(const MachineRegister& reg) {
  if (reg.isPhysical()) {
    return getPhysicalRegisterName(reg.reg_num);
  } else {
    // 虚拟寄存器不应该出现在最终汇编中
    return "%v" + std::to_string(reg.reg_num) + "?";
  }
}

void RISCVCodeEmitter::emitTextSection() {
  *output_stream << ".text\n";
}

void RISCVCodeEmitter::emitDataSection() {
  *output_stream << ".data\n";
}

void RISCVCodeEmitter::emitGlobalDirective(const std::string& symbol) {
  *output_stream << ".globl " << symbol << "\n";
}

void RISCVCodeEmitter::emitGlobalVariable(const MachineModule::GlobalVariable& global_var) {
  // 输出全局变量定义
  *output_stream << global_var.name << ":\n";
  
  if (global_var.type == MachineModule::GlobalVariable::INT) {
    // 整数类型
    *output_stream << "    .word " << global_var.value << "\n";
  } else if (global_var.type == MachineModule::GlobalVariable::FLOAT) {
    // 浮点类型 - 需要从int64_t还原float值
    float float_val;
    memcpy(&float_val, &global_var.value, sizeof(float));
    *output_stream << "    .float " << float_val << "\n";
  }
}

void RISCVCodeEmitter::emitComment(const std::string& comment) {
  *output_stream << "# " << comment << "\n";
}

bool RISCVCodeEmitter::needsSpecialHandling(const MachineInstruction& inst) {
  // 检查是否需要特殊处理（比如伪指令展开）
  return false;
}

void RISCVCodeEmitter::handleSpecialInstruction(const MachineInstruction& inst) {
  // 处理需要特殊格式的指令
  (void)inst; // 避免未使用参数警告
}

std::string RISCVCodeEmitter::getPhysicalRegisterName(int reg_num) {
  static const std::string gpr_names[] = {
    "zero", "ra", "sp", "gp", "tp", "t0", "t1", "t2",
    "s0", "s1", "a0", "a1", "a2", "a3", "a4", "a5",
    "a6", "a7", "s2", "s3", "s4", "s5", "s6", "s7",
    "s8", "s9", "s10", "s11", "t3", "t4", "t5", "t6"
  };
  
  if (reg_num >= 0 && reg_num < 32) {
    return gpr_names[reg_num];
  }
  return "x" + std::to_string(reg_num);
}

std::string RISCVCodeEmitter::formatImmediate(int64_t value) {
  return std::to_string(value);
}

std::string RISCVCodeEmitter::formatFloatImmediate(float value) {
  // RISC-V浮点立即数格式
  // 对于较小的浮点常量，可以直接使用十进制表示
  std::ostringstream ss;
  ss << std::fixed << std::setprecision(6) << value;
  return ss.str();
}

std::string RISCVCodeEmitter::formatAddress(const MachineOperand& base, const MachineOperand& offset) {
  std::string result;
  if (offset.isImm()) {
    result += std::to_string(offset.imm);
  }
  result += "(";
  result += formatOperand(base);
  result += ")";
  return result;
} 