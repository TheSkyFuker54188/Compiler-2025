// SysY兼容的SSA优化测试用例

int test_constant_folding() {
    // 测试常量折叠
    int a = 10 + 5;        // 应该折叠为 15
    int b = 20 * 2;        // 应该折叠为 40  
    int c = 100 / 4;       // 应该折叠为 25
    int d = 50 - 30;       // 应该折叠为 20
    return a + b + c + d;  // 应该折叠为 100
}

int test_algebraic_simplification() {
    // 测试代数化简
    int x = 42;
    int a = x + 0;         // 应该简化为 x
    int b = x * 1;         // 应该简化为 x
    int c = x - 0;         // 应该简化为 x
    int d = 0 + x;         // 应该简化为 x
    int e = 1 * x;         // 应该简化为 x
    int f = 0 * x;         // 应该简化为 0
    return a + b + c + d + e + f;
}

int test_dead_code_elimination() {
    // 测试死代码消除
    int alive = 5;
    int dead1 = 10;        // 未使用，应该被删除
    int dead2 = dead1 + 20; // 未使用，应该被删除
    
    int used = alive * 2;
    int another_dead = 99;  // 未使用，应该被删除
    
    return used;           // 只有alive和used应该保留
}

int test_copy_propagation() {
    // 测试复制传播
    int original = 100;
    int copy1 = original;   // copy1 应该被原值替代
    int copy2 = copy1;      // copy2 应该被原值替代
    int copy3 = copy2;      // copy3 应该被原值替代
    
    return copy3;           // 应该直接返回 original
}

int test_phi_simplification() {
    // 测试φ函数简化
    int x;
    int condition = 1;
    
    if (condition) {
        x = 42;             // 两个分支都赋相同值
    } else {
        x = 42;             // φ函数应该被简化
    }
    
    return x;               // 应该直接返回 42
}

int test_constant_propagation_through_branches() {
    // 测试通过分支的常量传播
    int x = 10;            // 常量
    int y;
    
    if (x > 5) {           // 应该被识别为恒为真
        y = 20;
    } else {
        y = 30;            // 不可达
    }
    
    return y;              // 应该被优化为返回 20
}

int test_nested_expressions() {
    // 测试嵌套表达式优化
    int a = 5;
    int b = 10;
    int c = 15;
    
    // 复杂表达式，包含多种优化机会
    int result = (a * 1) + (b + 0) + (c - 0) + (0 * 100);
    
    return result;          // 应该优化为 a + b + c = 30
}

int test_simple_loop() {
    // 简单的循环测试
    int sum = 0;
    int i = 0;

    while(i < 5) {
        sum = sum + i;
        i = i + 1;
    }
    
    return sum;             // 应该返回5
}

int test_arithmetic_optimization() {
    // 算术优化测试
    int x = 10;
    int y = 20;
    
    int a = x + x;          // 可能优化为 x * 2
    int b = y - y;          // 应该优化为 0
    int c = x / 1;          // 应该优化为 x
    int d = y % 1;          // 应该优化为 0（如果支持）
    
    return a + b + c + d;
}

int main() {
    int total = 0;
    
    total = total + test_constant_folding();
    total = total + test_algebraic_simplification();
    total = total + test_dead_code_elimination();
    total = total + test_copy_propagation();
    total = total + test_phi_simplification();
    total = total + test_constant_propagation_through_branches();
    total = total + test_nested_expressions();
    total = total + test_simple_loop();
    total = total + test_arithmetic_optimization();
    
    return total;
}
